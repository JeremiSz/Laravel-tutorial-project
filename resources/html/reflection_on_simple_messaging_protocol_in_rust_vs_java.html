---
title: "Reflection on the Simple Messaging Protocol in Rust vs. Java"
date: "2023-07-24"
sample: "Not so long ago, a class of mine required creating a multithreaded back end and front end for a simple protocol. This project included many important aspects of a language including: CLI IO, error han"
path: "reflection_on_simple_messaging_protocol_in_rust_vs_java"
---
<p>Not so long ago, a class of mine required creating a multithreaded back end and front end for a simple protocol. This project included many important aspects of a language including: CLI IO, error handling, spawning threads, shared thread memory and TCP Streams. As such, I\'ve been using it as a starting point to learn new languages.</p><p>Here are findings I have having rewritten the Java version in Rust.</p><h3>Structure</h3><p>The images above show the structures of the 2 projects. The numbers are the lines of code for each file. For those unfamiliar with Rust may be thinking "Java is so much more compact and readable. For those I have a question, what is the entry point of this program? This is a bit of a trick question as the Java project has no "main.java". Still Java\'s flat layout gives no information on ownership. Rust\'s directories within directories can look odd. However, each directory is a module (aka package). The mod.rs is always the main file of the module. In the application module in client, the entry point of the module can easily be found despite it having 2 sub modules.</p><p>It is true a similar structure can be taken in Java. Walter Bright does suggest <a href="https://youtu.be/y7KWGv_t-MU">a talk of his</a> on how standards not enforced by the language possess significant costs, including longer on boarding and less compatible tooling.</p><p>I do have to reveal these examples are not quite apples to apples. The Java application has a basic GUI while the Rust version just has a CLI. Despite this, both projects have been divided up similarly.</p><h3>Abstraction</h3><p>When I was being sold OOP (and Java), there was a lot of focus on the ability for objects to hide complexity and create more readable code. Personally, I found Rust\'s structures and bound functions to be sufficient for what Java classes offer. Still, these structures are not limited to being heap allocated objects. In Rust, I could have the SMT Helpers and Presentation modules just hold code and data which can be called directly. In Java, I need to instantiate classes doing the same work.</p><h3>Errors</h3><p>The 2 languages handle errors in different ways. Java uses exceptions as is popular in JavaScript and C#. Rust uses return values as errors as in C and Go. I am not going to pass judgement on either strategy as I feel too inexperienced with either to have any deep insight. Still try/catch blocks do separate the valid path from error handling. This can allow error handling to be more forgotten or obscure where the error originated. Rust has a special type for errors, Result. A method can return an output or an error. Once returned, the error must be checked for before the value can be used. As such, error handling becomes a readable part of the code\'s flow.</p><p>Personally, I have enjoyed the return value strategy more as I prefer thinking of exceptions as part of the logic and not a special case.</p><h3>Threads and Memory</h3><p>Creating threads was straight forward in both languages. The process was easier in Java. There, I split the thread code into a class. The server does include memory shared between all threads. In Java, this was an object all threads got a reference to. That object\'s class had to have the synchronised keyword in its methods to avoid concurrent memory issues.  Rust passed a lambda to the thread spawning code which had a function with the thread code. Passing the shared memory was more complex as the data structure needed to be wrapped behind a mutex and asynchronous reference count (aka Arc). To quickly break those down, the mutex provided the memory locking provided by the synchronised keyword in Java. The Arc was a means of allowing multiple references to the data store. By default, Rust has a borrowing system where only one frame can own a mutable reference to an object. Once a reference is finished in a frame and not returned, the object is cleaned up. The Arc allows multiple references to be owned by keeping a count of how many exists and only cleaning once all are removed.</p><p>Comparing the 2 systems, Rust is clearly more complex. That is partially due to Rust\'s more explicit memory management. This complexity does hold a benefit. With both the mutex and Arc being external to the underlying memory, they can be applied to any structure without modification to that structure. Java requires classes used have synchronised methods or be decorated by synchronised methods. Rust also allows for other implementations which may be more applicable to said problem domain.</p><h3>Quick Bits</h3><p>Java is opinionated on the side against infinite loops. A good old while(true) or for(;;) will cause warnings. It is suggested sentinel variables are used. Rust does not share this opinion having a first party infinite loop, called loop. It has no issue with breaks being used to escape this loop.</p><p>One issue I ran into in Rust was trying to recreate the constants used for formatted messages. Rust\'s string interpolation uses macros. These macros require string literals so constant variables are not allowed. Trying to fix this took me down the rabbit hole of lifetimes as attempts at creating variables referencing literals causes Rust to start asking how long the variables should exist for. At the time, I side stepped that topic by moving the strings into the functions.</p><h3>Last bit</h3><p>Despite this not being a large scale code base, I found the process of recreating the same code quite good for getting to grips with the basics of a language. More so, I have felt how learning more (different) languages can expand on how you think about code which is a message you have probably heard before.</p><p>I chose not to get into explaining many of the features of either language. There are plenty of guides and tutorials online but if you\'d like a chat about them, <a href="https://www.linkedin.com/in/jeremi-szlapka/">do reach out.</a></p>