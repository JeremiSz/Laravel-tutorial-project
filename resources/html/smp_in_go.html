---
title: "SMP in Go"
date: "2023-07-31"
sample: "Continuing from the previous comparison between Java and Rust, I have rewritten the program in Go. This"
path: "smp_in_go"
---
<p>Continuing from the <a href="https://jeremisz.blogspot.com/2023/07/reflection-on-simple-messaging-protocol.html">previous comparison between Java and Rust</a>, I have rewritten the program in Go. This is only a quick port of the Rust CLI version and unlike Rust, I have only spent a week learning Go. Still, I have heard it is a language that focuses on simple but effective tools that are quick to pick up so hopefully this comparison is still valuable.</p><p><a href="https://github.com/JeremiSz/SMP_Go">Link to the repo: https://github.com/JeremiSz/SMP_Go</a></p><h3>Structure</h3><p>Go returns to a Java like package system. Unlike Java, there are no objects so packages carry the encapsulation of both packages and classes. I mistakenly treated them as just Java packages and found the name spaces quickly filling up. This does pose problem not only due to functions being less organised but also due to Go not allowing function overloading. This isn’t an issue but something to consider when designing your package structure.</p><p>Some may assume Go’s simplicity would result in a ballooning line count. For this project, I did not see that. Maybe just because this was a port form one to the next but the line counts are all fairly similar. Each language posses features with extend the lines. Java has class declarations and constructors, Rust has long types of types (of types).</p><h3>Abstraction</h3><p>This is the area I did not have time to explore in Go. As such, I did not dive into Go’s interface system in depth. However, It does appear to be a simple means of allowing polymorphism without inheritance by treating any function with the same name and signature as valid for the interface. Bar that, give me one more week.<h3>Errors</h3><p>Here Go is interesting. Errors are, by convention, returned as the second return value of a function. This becomes similar to the Result struct in Rust but without the bespoke boilderplate required to check and handle errors. Instead errors can be checked for with a simple equality to nil. Errors can also be returned further up without any new syntax. It is nice that Go has Rust’s strengths without more content to learn.</p><h3>Concurrency</h3><p>Spinning up threads is easier in Go than in the other 2. Just placing the keyword “go” before a function call moves it off the main thread. Then, Go provides a few simple structures to control and communicate between threads. These can be passed in and treated as any over variable in the system. The first I came across was the channel. This is a means of sending messages to other threads. Though simply, it is just a means of sending messages, with threads just being a recommended use case. Another is a wait group. This is an object which counts how many threads it exists in, then can wait until “done” is called in the same amount. One tool that I did use was the lock. Unlike Java, locks are not keywords attached to methods, nor the wrappers in Rust. Locks are just variables. There is no explicit binding between data and the locks as the developer is free to tie the lock with anything in the logic. It is much more flexible than the async reference counter in Rust. Concurrency is something that Go integrates very easily without loosing its simple procedural and readable style.</p><h3>Quick Bit</h3><p>The defer keyword was a nice way to make sure resources were cleaned. All it does is make the function following it run once the current function returns. As such, you can close a connection after opening it visually but have it only logically close at the end.</p><p>So turns out Go is easy to pick up and use quickly. I do not claim to have mastered it but I do feel I could use it for substantial project having only spent a week on it.</p>
